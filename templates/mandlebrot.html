<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Mandelbrot</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
      cursor: grab;
    }
  </style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script id="vertexShader" type="x-shader/x-vertex">
attribute vec2 a_position;
void main() {
  gl_Position = vec4(a_position, 0.0, 1.0);
}
</script>
<script id="fragmentShader" type="x-shader/x-fragment">
precision highp float;
uniform vec2 u_resolution;
uniform vec2 u_center;
uniform float u_zoom;
uniform float u_maxIter;

vec3 getColor(float iter, float maxIter) {
  if (iter == maxIter) return vec3(0.0);
  float t = iter / maxIter;
  return vec3(0.5 + 0.5*cos(6.2831*(t+vec3(0.0,0.3,0.6))));
}

void main() {
  vec2 c = u_center + (gl_FragCoord.xy - 0.5 * u_resolution) * u_zoom / u_resolution.y;
  vec2 z = vec2(0.0);
  float iter = 0.0;
  float x, y;
  for (int i = 0; i < 1000; i++) {
    if (float(i) >= u_maxIter) break;
    x = (z.x * z.x - z.y * z.y) + c.x;
    y = (2.0 * z.x * z.y) + c.y;
    if ((x * x + y * y) > 4.0) break;
    z = vec2(x, y);
    iter += 1.0;
  }
  gl_FragColor = vec4(getColor(iter, u_maxIter), 1.0);
}
</script>
<script>
const canvas = document.getElementById("glcanvas");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const gl = canvas.getContext("webgl");

function compileShader(id, type) {
  const src = document.getElementById(id).text;
  const shader = gl.createShader(type);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(shader));
  }
  return shader;
}

const vs = compileShader("vertexShader", gl.VERTEX_SHADER);
const fs = compileShader("fragmentShader", gl.FRAGMENT_SHADER);

const prog = gl.createProgram();
gl.attachShader(prog, vs);
gl.attachShader(prog, fs);
gl.linkProgram(prog);
if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
  console.error(gl.getProgramInfoLog(prog));
}
gl.useProgram(prog);

const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1, -1,
   1, -1,
  -1,  1,
  -1,  1,
   1, -1,
   1,  1
]), gl.STATIC_DRAW);

const posLoc = gl.getAttribLocation(prog, "a_position");
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

const u_resolution = gl.getUniformLocation(prog, "u_resolution");
const u_center = gl.getUniformLocation(prog, "u_center");
const u_zoom = gl.getUniformLocation(prog, "u_zoom");
const u_maxIter = gl.getUniformLocation(prog, "u_maxIter");

let zoom = 3.0;
let center = { x: -0.5, y: 0.0 };
let maxIter = 500.0;

function render() {
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.uniform2f(u_resolution, canvas.width, canvas.height);
  gl.uniform2f(u_center, center.x, center.y);
  gl.uniform1f(u_zoom, zoom);
  gl.uniform1f(u_maxIter, maxIter);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
}

canvas.addEventListener("wheel", e => {
  const zoomFactor = 1.1;
  const mouseX = e.clientX;
  const mouseY = e.clientY;
  const dx = (mouseX - canvas.width / 2) * zoom / canvas.height;
  const dy = (mouseY - canvas.height / 2) * zoom / canvas.height;
  center.x += dx;
  center.y += dy;
  zoom *= e.deltaY < 0 ? 1 / zoomFactor : zoomFactor;
  center.x -= (mouseX - canvas.width / 2) * zoom / canvas.height;
  center.y -= (mouseY - canvas.height / 2) * zoom / canvas.height;
  maxIter += 10;
  render();
});

let dragging = false;
let lastX = 0, lastY = 0;

canvas.addEventListener("mousedown", e => {
  dragging = true;
  lastX = e.clientX;
  lastY = e.clientY;
  canvas.style.cursor = "grabbing";
});

canvas.addEventListener("mouseup", () => {
  dragging = false;
  canvas.style.cursor = "grab";
});

canvas.addEventListener("mousemove", e => {
  if (dragging) {
    const dx = (e.clientX - lastX) * zoom / canvas.height;
    const dy = (e.clientY - lastY) * zoom / canvas.height;
    center.x -= dx;
    center.y += dy;
    lastX = e.clientX;
    lastY = e.clientY;
    render();
  }
});

render();
</script>
</body>
</html>